/// Модуль, в котором содержаться процедуры решения задач со списками
Unit Tasks_Unit_2;


interface //####################################################################


  uses Task_545_Unit, List_Unit, Math_Unit;
  
  
  
  
  /// Процедура для выполнения задания 531
  procedure Task_531();
  
  
  /// Процедура для выполнения задания 534 (a)
  procedure Task_534_a();
  
  
  /// Процедура для выполнения задания 545
  procedure Task_545();
  
  
  
  
implementation //###############################################################



  procedure Task_531();
    
  // #######################
    
    
      
  // #######################
    
    var
    
      LH, R : real_LH;                    // Первый эелемент нашего списка и результирующий список
    
      n, i : integer;                     // n - вводимое значение, i - счётчик
      
      HR : real_LH;                       // "Точка сохранения" результирующей "головы" списка
      
    begin
    
      
      writeln('Введите число n (n > 1):');  // Просим...
      readln(n);                          // Получаем размерность будущего массива
      
      if n < 2 then                       // В случае ошибки, так и говорим
        
        writeln('Введено некоректное число!')
        
      else                                // Если всё хорошо, то:
        begin
          
          
          new(LH);                        // Выделяем память для первого элемента списка
          
          new(R);                         // The same...
          
          new(HR);                        // The same...
          
          
          
          LH^.Content := GRRV(10);        // Заполняем изначальную "голову"
          
          nL(LH, n);                      // Расширяем список, заполняя его случайными real числами
          
          writeln('Изначальный список:');
          Show_List(LH);                  // Выводим изначальный список в консоль
          
          
                      // Заполняем 1-ый элемент результирующего списка
                      
          
          nL(R, n - 1);                               // Заполняем R случ. числами, чтобы оказаться в начале списка
          
          R^.Content := LH^.Content - GVoLE(LH);      // Заполняем изначальную "голову"
          
          HR := R;                        // Резервируем "голову" результирующего списка
          
          
          
                      // А теперь, зная самый 1-ый элемент R, приступаем к циклу...
          
         
          for i := 1 to n - 2 do          
            begin
            
            
              LH := LH^.Next;             // Переключаемся на следующий элемент (В начале, ибо мы уже получили 1-ый элемент списка R)
              
              R := R^.Next;               // Записываем полученную сумму в результирующий список
          
              R^.Content := LH^.Content - GVoLE(LH);      // Получаем нужную по условиям сумму
              
          
            end;
            
            
          R := HR;                        // Возвращаем "голову" на место
          
          
          writeln('Результирующий список:');
          Show_List(R);                   // Выводим результирующий список в консоль
        
        end;
    
    end;
  
  
  
  procedure Task_534_a();
    
    var
    
    
      i, n : integer;                     // n - вводимое значение n
      
      LH : Real_LH;                       // Первый эелемент нашего списка
      
      res : real;                         // Переменная для вывода результата
      
      
      
    begin
    
      res := 1;                           // "Обнуляем" результат, т.к. эта переменная будет перемножаться
      
      writeln('Введите число n (n > 0):');  // Просим...
      readln(n);                          // Получаем размерность будущего массива
      
      if n < 1 then                       // В случае ошибки, так и говорим
        
        writeln('Введено некоректное число!')
        
      else                                // Если всё хорошо, то:
        begin
          
          
          new(LH);                        // Выделяем память для первого элемента списка
          
          res := 1;                       // "Обнуляем" результат, т.к. эта переменная будет перемножаться
          
          
          
          LH^.Content := GRRV(10);        // Заполняем изначальную "голову"
          
          nL(LH, 2 * n);                  // Расширяем список, заполняя его случайными real числами
          
          writeln('Изначальный список:');
          Show_List(LH);                  // Выводим изначальный список в консоль
          
          
          for i := 0 to n - 1 do          // Основная задача программы - вычисление...
          
          
            res := res * (GVoSE(LH, 2 * i + 1) - GVoSE(LH, (2 * n) - i * 2));
            
            
          writeln('Итоговый результат: ', res :4 :4);
          
      end;
          
    
    end;
    
  
  
  procedure Task_545();
    
    var 
    
      i, n, m, t1 : integer;                          // n - вводимое значение n; i - счётчик; число m
    
      LH, FE, t2 : Int_LH;                            // Первый эелемент нашего списка и "точка сохранения головы"
    
    
    begin
    
    
      writeln('Введите число n (кол-во людей):');
      readln(n);                                  // Получаем размерность будущего списка - кол-во людей
      
      
      writeln('Введите число m:');                // Получаем число m
      readln(m);
      
      if (n < 1) or (m < 1) then
        
        writeln('Введены некоректные значения!')
      
      else
        begin
        
          new (LH);                               // Выделяем память
          
          new (FE);                               // The same...
          
          new (t2);
          
        
          LH^.Content := n;                       // Инициализируем 1-ый элемент списка
          
          nL(LH, n - 1);                          // Заполняем список
          
          FE := LH;                               // Запоминаем "голову"
          
          LH := GTLE(LH);                         // Переключаемся на последний элемент списка
          
          LH^.Next := FE;                         // Замыкаем список в кольцо
          
          LH := FE;                               // Возвращаемся на 1-ый элемент
          
          
          writeln('Изначальный список:');
          show_list(LH);
          
          
          if m <> 1 then
          
            writeln('Result: ', Take_Out_Task_545(LH, m))
            
          else
            
            writeln('Result: ', n);
        
        end;
      
    
    end;
  
      
begin //########################################################################
    
    
    
end. //#########################################################################